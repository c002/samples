/*
 * Note: partially auto-generated by mib2c using
 *        : mib2c.create-dataset.conf,v 5.3 2002/12/05 00:29:45 hardaker Exp $
 *
 *
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <net-snmp/utilities.h>
#include <time.h>

#include <sys/types.h>
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include "bdf_api.h"
#include "flowtagTable.h"

/* single units of interesting netflow related info */
uint32_t global_flowcount=0;		/* single OID */
unsigned long global_timestamp=0;	/* single OID */

/* Track table so it can be refreshed at intervals */
struct table_bits {
    netsnmp_table_data_set *table;		/* Table structure */
    netsnmp_table_row *row[MAX_ROWS];		/* Array of all my rows */
    int rowcount;				/* Number of rows */
} MY_TABLE;

int fill_table( struct table_bits *my_table);
void flowtagTable_update(unsigned int reg, void *args);

/** Initialize the flowtagTable table by defining its contents and how it's structured */
void
initialize_table_flowtagTable(void)
{
    static oid NetflowTimestamp_oid[] = { 1,3,6,1,4,1,17458,1,1,5, 0 };
    static oid NetflowFlowCount_oid[] = { 1,3,6,1,4,1,17458,1,1,3, 0 };

    static oid flowtagTable_oid[] = {1,3,6,1,4,1,17458,2,3};
    size_t flowtagTable_oid_len = OID_LENGTH(flowtagTable_oid);
    netsnmp_table_data_set *table_set;	

    netsnmp_table_row *row;
    int i, update_time;
    time_t target_time;
    struct table_bits *my_table;	

    /* Set a few sigle OID's */
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("NetflowTimestamp",
                                         get_NetflowTimestamp,
                                         NetflowTimestamp_oid,
                                         OID_LENGTH(NetflowTimestamp_oid),
                                         HANDLER_CAN_RONLY));
    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("NetflowFlowCount",
                                         get_NetflowFlowCount,
                                         NetflowFlowCount_oid,
                                         OID_LENGTH(NetflowFlowCount_oid),
                                         HANDLER_CAN_RONLY));

    /* Do the table stuff */
    if ( !(my_table = (struct table_bits *) malloc(sizeof(struct table_bits)))) {
	printf("Failed malloc\n");
	return;
    }

    /* create the table structure itself */
    table_set = netsnmp_create_table_data_set("flowtagTable");

    my_table->table = table_set;
    my_table->rowcount = 0;

    /* comment this out or delete if you don't support creation of new rows */
    table_set->allow_creation = 1;

    /***************************************************
     * Adding indexes
     */
    DEBUGMSGTL(("initialize_table_flowtagTable",
                "adding indexes to table flowtagTable\n"));
    netsnmp_table_set_add_indexes(table_set,
                           ASN_INTEGER,  /* index: flowtagIndex */
                           0);

    DEBUGMSGTL(("initialize_table_flowtagTable",
                "adding column types to table flowtagTable\n"));		 
    netsnmp_table_set_multi_add_default_row(table_set,
                                            COLUMN_FLOWTAGINDEX, ASN_INTEGER, 0,
                                            NULL, 0,
                                            COLUMN_FLOWTAGDESCR, ASN_OCTET_STR, 0,
                                            NULL, 0,
                                            COLUMN_FLOWTAGMBYTESFROM, ASN_COUNTER, 0,
                                            NULL, 0,
                                            COLUMN_FLOWTAGMBYTESTO, ASN_COUNTER, 0,
                                            NULL, 0,
                                            COLUMN_FLOWCOUNTBYTAG, ASN_COUNTER, 0,
                                            NULL, 0,
                              0);
    
    /* registering the table with the master agent */
    /* note: if you don't need a subhandler to deal with any aspects
       of the request, change flowtagTable_handler to "NULL" */
    netsnmp_register_table_data_set(netsnmp_create_handler_registration("flowtagTable", flowtagTable_handler,
                                                        flowtagTable_oid,
                                                        flowtagTable_oid_len,
                                                        HANDLER_CAN_RWRITE),
                            table_set, NULL);

    /* Setup initial values . Initially we have no stats as starttime
	is unknown  */
/*
    fill_table(my_table);
*/
    /* Register callback alarm function for updating table data */
    target_time = ( ( (unsigned int) (time(NULL) / INTERVAL)+1) * INTERVAL) + OFFSET;
    update_time = target_time - time(NULL);
    if (update_time > INTERVAL)
          update_time=update_time - INTERVAL;

/* To avoid drift, re-register the callback after each run 
    if (! (snmp_alarm_register(update_time, SA_REPEAT , flowtagTable_update, my_table)) )
*/
    if (! (snmp_alarm_register(update_time, NULL , flowtagTable_update, my_table)) )
	printf("Fail to reg callback\n"); fflush(stdout);
    

}

/** Initializes the flowtagTable module */
void
init_flowtagTable(void)
{

  /* here we initialize all the tables we're planning on supporting */
    initialize_table_flowtagTable();
}

/** handles requests for the flowtagTable table, if anything else needs to be done */
int
flowtagTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    /* perform anything here that you need to do.  The requests have
       already been processed by the master table_dataset handler, but
       this gives you chance to act on the request in some other way
       if need be. */

    return SNMP_ERR_NOERROR;
}

/*
 * flowtagTable_update()
 *	
 * 	Callback func to update the SNMP table stats 
 */
void flowtagTable_update(unsigned int reg, void *args)
{

    static unsigned int counter=0;
    int i, update_time;
    time_t	target_time;
    struct table_bits *my_table = (struct table_bits *) args; 

    /* printf("Callback func invoked at %u [%u]\n", time(NULL), counter++); */

     /* Clear previous rows */
     /* perhaps have 2 tables, so we can flip pointers when updating */
     for (i=0; i<my_table->rowcount; i++) {
	 /* Remove row from table */
         netsnmp_table_dataset_remove_row(my_table->table, my_table->row[i]);
	 /* Free mem */
         netsnmp_table_dataset_delete_row(my_table->row[i]);
     }
     my_table->rowcount=0;
     fill_table(my_table);	/* Update stats */

     /* Register callback alarm function to update the data */
     target_time = ( ( (unsigned int) (time(NULL) / INTERVAL)+1) * INTERVAL) + OFFSET;
     update_time = target_time - time(NULL);
     if (update_time > INTERVAL)
          update_time=update_time - INTERVAL;
     if (! (snmp_alarm_register(update_time, NULL , flowtagTable_update, my_table)) ) {
	printf("Fail to set alarm\n"); fflush(stdout);	
	return;
     }

     return;

}

/***
 *
 * fill_table()
 *	Opens all BDF files in a known directory and summarises the flows
 *	by FlowTag. If multiple files, it is assumed to be part of the same
 *	sample period and stats are totalled.
 *      It than stores this stuff internally where they can be retrieved 
 *      with an SNMP request
 *
 ***/
int fill_table(struct table_bits *my_table)
{
    time_t target_time;
    netsnmp_table_row *row;
    int i;

    FILE *f;
    uint32_t total_flowcount=0;
    uint32_t mbytes_from=0, mbytes_to=0, countbytag=0;
    int res, update_time;
    struct summarydetails summary[MAX_TAGS], total_sum[MAX_TAGS];
    DIR *dirp;
    struct dirent *dp;
    char fpath[256];
    struct bdf_headers *bh=NULL;

    for (i=0; i<MAX_TAGS; i++) {
        total_sum[i].total_to_bytes=0;
        total_sum[i].total_from_bytes=0;
        total_sum[i].count=0;
    }
        
    if (! (dirp = opendir(NETFLOW_DIR))) {
	fprintf(stderr,"Failed to open netflow dir\n");
	return(-1);
    }

    while ((dp = readdir(dirp))) {
            if (strncmp("netflow",dp->d_name,strlen("netflow"))==0) {
                sprintf(fpath,"%s/%s", NETFLOW_DIR,dp->d_name);
                if (!(f = fopen(fpath,"r"))) {
                    fprintf(stderr,"Unable to open file\n");
                    return(-1);
                }

	        if (bh) free_bdf_headers(bh);	/* pass >1 */
                if (! (bh = (struct bdf_headers *) calloc(1,sizeof(struct bdf_headers)))) {
		    fprintf(stderr,"Failed to calloc bh\n"); fflush(stdout);
		    return(0);
		}

                total_flowcount = total_flowcount+ bdf_flowcount(f);

		if (total_flowcount<0) {
		    fprintf(stderr, "Barf: %d\n", total_flowcount);
		}

                bdf_readhead(f, bh);

                res = bdf_summary(f, summary);
                for (i=0; i<bh->taghead->rows; i++) {
                    if (bh->tagdic[i]) {
                        total_sum[i].total_to_bytes=total_sum[i].total_to_bytes + summary[i].total_to_bytes;
                        total_sum[i].total_from_bytes=total_sum[i].total_from_bytes + summary[i].total_from_bytes;
                        total_sum[i].count=total_sum[i].count + summary[i].count;

                    }
                }
                fclose(f);
           }
    }

    /* set some globals to update single OID's */
    global_flowcount=total_flowcount;
    global_timestamp=time(NULL);

    if (bh && bh->taghead && bh->taghead->rows) {	/* Anything to do ? */
        for (i=0; i<bh->taghead->rows; i++) {
            if (bh->tagdic[i]) {

                   row = netsnmp_create_table_data_row();
	           my_table->row[my_table->rowcount]=row;
	           my_table->rowcount++;

		   mbytes_from = (uint32_t) (total_sum[i].total_from_bytes/1000000);
		   mbytes_to = (uint32_t) (total_sum[i].total_to_bytes/1000000);
		   countbytag = total_sum[i].count;
/* XXX */
/* printf("from=%llu\n", total_sum[i].total_from_bytes); */
        	  /* set the index to */
                   netsnmp_table_row_add_index(row, ASN_INTEGER, (u_char *) &i,
                                		sizeof(int));

                  /* set column 2 */
                   netsnmp_set_row_column(row, COLUMN_FLOWTAGDESCR, ASN_OCTET_STR,
                           bh->tagdic[i], strlen(bh->tagdic[i]));
        	  /* set column 3 */
                   netsnmp_set_row_column(row, COLUMN_FLOWTAGMBYTESFROM, ASN_COUNTER,
                           (u_char *) &mbytes_from, sizeof(mbytes_from));
		
        	  /* set column 4 */
                   netsnmp_set_row_column(row, COLUMN_FLOWTAGMBYTESTO, ASN_COUNTER,
                           (u_char *) &mbytes_to, sizeof(mbytes_to));
		
        	  /* set column 5 */
                   netsnmp_set_row_column(row, COLUMN_FLOWCOUNTBYTAG, ASN_COUNTER,
                           (u_char *) &countbytag, sizeof(countbytag));
		
		  /*
                   netsnmp_mark_row_column_writable(row, 2, 1);   
	          */

                  /* add the row to the table */
                   netsnmp_table_dataset_add_row(my_table->table, row);
	   }
        }	/* for */
    }

    if (bh)  free_bdf_headers(bh);
    closedir(dirp);

    return 1;
}
/***
 * Dummy placeholder func ( that doesn't leak)
 *
 ***/
int xfill_table(struct table_bits *my_table)
{
    netsnmp_table_row *row;
    char *data1="SOME_TAG";
    int i, data2=1234;
    int data3=5678;

    for (i=0; i<5; i++) {
         row = netsnmp_create_table_data_row();
	 my_table->row[my_table->rowcount]=row;
	 my_table->rowcount++;

      /*
       * set the index to 
       */
       netsnmp_table_row_add_index(row, ASN_INTEGER, (u_char *) &i,
                                		sizeof(int));

       /*
        * set column 2
        */
        netsnmp_set_row_column(row, COLUMN_FLOWTAGDESCR, ASN_OCTET_STR,
                           data1, strlen(data1));
        /*
         * set column 3
         */
         netsnmp_set_row_column(row, COLUMN_FLOWTAGMBYTESFROM, ASN_COUNTER,
                           (u_char *) &data2, sizeof(data2));
		
       /*
       * set column 4
       */
       netsnmp_set_row_column(row, COLUMN_FLOWTAGMBYTESTO, ASN_COUNTER,
                           (u_char *) &data3, sizeof(data3));
		
	/*
	netsnmp_mark_row_column_writable(row, 2, 1);   
	*/
	/*
	* add the row to the table 
	*/
	netsnmp_table_dataset_add_row(my_table->table, row);
        }
}

/*
 * These funcs are called when accessing the single OID's defined
 * above 
 */
int
get_NetflowFlowCount(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &global_flowcount, sizeof(global_flowcount));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
get_NetflowTimestamp(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *) &global_timestamp, sizeof(global_timestamp));
            break;


        default:
            /* we should never get here, so this is a really bad error */
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
